import json
import math
from typing import List, Tuple
import sys

def load_json_file(filename: str):
    with open(filename, 'r') as f:
        data = json.load(f)
    
    start_pos = tuple(data["InitialPosition"])
    initial_angle = data["InitialAngle"]
    v_max = data["StageVelocity"]
    a_max = data["StageAcceleration"]
    omega_max = data["CameraVelocity"]
    alpha_max = data["CameraAcceleration"]
    
    dies = data["Dies"]
    
    centers = []
    target_angles = []
    
    for die in dies:
        corners = die["Corners"]
        cx = sum(c[0] for c in corners) / 4.0
        cy = sum(c[1] for c in corners) / 4.0
        centers.append((cx, cy))
        
        dx = corners[1][0] - corners[0][0]
        dy = corners[1][1] - corners[0][1]
        angle = math.degrees(math.atan2(dy, dx))
        target_angles.append(angle)
    
    return {
        "start_pos": start_pos,
        "initial_angle": initial_angle,
        "v_max": v_max,
        "a_max": a_max,
        "omega_max": omega_max,
        "alpha_max": alpha_max,
        "centers": centers,
        "target_angles": target_angles
    }

def trapezoidal_time(distance: float, v_max: float, a_max: float) -> float:
    if distance <= 0:
        return 0.0
    if a_max <= 0 or v_max <= 0:
        return distance / v_max if v_max > 0 else float('inf')
    
    # Correct total ramp distance: accel to v_max + decel from v_max
    ramp_dist = v_max ** 2 / a_max
    
    if distance <= ramp_dist:
        # Pure triangular profile
        return 2 * math.sqrt(distance / a_max)
    else:
        # Trapezoidal: cruise at v_max
        cruise_dist = distance - ramp_dist
        cruise_time = cruise_dist / v_max
        ramp_time = v_max / a_max * 2  # accel + decel
        return cruise_time + ramp_time


def angular_trapezoidal_time(delta_angle: float, omega_max: float, alpha_max: float) -> float:
    delta_angle = abs(delta_angle)
    if delta_angle <= 0:
        return 0.0
    if alpha_max <= 0 or omega_max <= 0:
        return delta_angle / omega_max if omega_max > 0 else float('inf')
    
    ramp_angle = omega_max ** 2 / alpha_max
    
    if delta_angle <= ramp_angle:
        return 2 * math.sqrt(delta_angle / alpha_max)
    else:
        cruise_angle = delta_angle - ramp_angle
        cruise_time = cruise_angle / omega_max
        ramp_time = omega_max / alpha_max * 2
        return cruise_time + ramp_time

def segment_time(
    p1: Tuple[float, float], angle1: float,
    p2: Tuple[float, float], angle2: float,
    v_max: float, a_max: float,
    omega_max: float, alpha_max: float
) -> float:
    distance = math.hypot(p2[0] - p1[0], p2[1] - p1[1])
    delta_angle = (angle2 - angle1) % 360
    delta_angle = min(delta_angle, 360 - delta_angle)
    if delta_angle%90==0:
        delta_angle=0
    else :
        if delta_angle>270:
            delta_angle=delta_angle-270
        elif delta_angle>180:
            delta_angle=delta_angle-180
        elif delta_angle>90:
            delta_angle=delta_angle-90
    trans_time = trapezoidal_time(distance, v_max, a_max)
    rot_time = angular_trapezoidal_time(delta_angle, omega_max, alpha_max)
    
    return max(trans_time, rot_time)

def nearest_neighbor_start(data, start_idx=None):
    start = data["start_pos"]
    centers = data["centers"]
    angles = data["target_angles"]
    n = len(centers)
    if n == 0:
        return [], 0.0
    
    unvisited = set(range(n))
    path = []
    current_pos = start
    current_angle = data["initial_angle"]
    total_t = 0.0
    
    if start_idx is not None:
        best_idx = start_idx
        unvisited.remove(best_idx)
        t = segment_time(current_pos, current_angle, centers[best_idx], angles[best_idx], data["v_max"], data["a_max"], data["omega_max"], data["alpha_max"])
        total_t += t
        path.append(best_idx)
        current_pos = centers[best_idx]
        current_angle = angles[best_idx]
    
    while unvisited:
        best_idx = min(unvisited, key=lambda i: segment_time(current_pos, current_angle, centers[i], angles[i], data["v_max"], data["a_max"], data["omega_max"], data["alpha_max"]))
        t = segment_time(current_pos, current_angle, centers[best_idx], angles[best_idx], data["v_max"], data["a_max"], data["omega_max"], data["alpha_max"])
        total_t += t
        path.append(best_idx)
        current_pos = centers[best_idx]
        current_angle = angles[best_idx]
        unvisited.remove(best_idx)
    
    return path, total_t

def two_opt_improve(data, init_path: List[int]) -> Tuple[List[int], float]:
    n = len(init_path)
    if n < 2:
        return init_path, 0.0
    
    best_path = init_path[:]
    
    def path_time(path):
        t = 0.0
        prev_pos = data["start_pos"]
        prev_angle = data["initial_angle"]
        for idx in path:
            t += segment_time(prev_pos, prev_angle, data["centers"][idx], data["target_angles"][idx], data["v_max"], data["a_max"], data["omega_max"], data["alpha_max"])
            prev_pos = data["centers"][idx]
            prev_angle = data["target_angles"][idx]
        return t
    
    best_time = path_time(best_path)
    improved = True
    
    while improved:
        improved = False
        for i in range(1, n-1):
            for j in range(i+2, n+1):
                new_path = best_path[:i] + best_path[i:j][::-1] + best_path[j:]
                new_time = path_time(new_path)
                if new_time < best_time - 1e-8:
                    best_path = new_path
                    best_time = new_time
                    improved = True
    
    return best_path, best_time

def get_best_path(data):
    centers = data["centers"]
    start = data["start_pos"]
    n = len(centers)
    
    # Start1: Standard NN from closest
    path1, _ = nearest_neighbor_start(data)
    path1, time1 = two_opt_improve(data, path1)
    
    # Start2: From farthest die
    if n > 0:
        farthest_idx = max(range(n), key=lambda i: math.hypot(centers[i][0]-start[0], centers[i][1]-start[1]))
        path2, _ = nearest_neighbor_start(data, farthest_idx)
        path2, time2 = two_opt_improve(data, path2)
    else:
        time2 = float('inf')
    '''
    # Start3: From 'left' end (min x or y)
    if n > 0:
        left_idx = min(range(n), key=lambda i: centers[i][0] if abs(centers[0][0] - centers[1][0]) > abs(centers[0][1] - centers[1][1]) else centers[i][1])
        path3, _ = nearest_neighbor_start(data, left_idx)
        path3, time3 = two_opt_improve(data, path3)
    else:
        time3 = float('inf')
    
    # Start4: From 'right' end (max x or y)
    if n > 0:
        right_idx = max(range(n), key=lambda i: centers[i][0] if abs(centers[0][0] - centers[1][0]) > abs(centers[0][1] - centers[1][1]) else centers[i][1])
        path4, _ = nearest_neighbor_start(data, right_idx)
        path4, time4 = two_opt_improve(data, path4)
    else:
        time4 = float('inf') ''' 
    
    # Pick best
    times = [(path1, time1), (path2, time2)]
    best_path, best_time = min(times, key=lambda x: x[1])
    
    return best_path, best_time

def solve_and_output(filename: str):
    data = load_json_file(filename)
    
    opt_path, total_time = get_best_path(data)
    
    path_coords = [list(data["start_pos"])]
    for idx in opt_path:
        path_coords.append([data["centers"][idx][0], data["centers"][idx][1]])
    
   
    result = {
        "TotalTime": round(total_time, 9),  # Safe: 9 decimals is more than enough
        "Path": path_coords
    }
    
    print(json.dumps(result, indent=2))
    
    output_file = filename.replace("Input_", "Output_").replace(".json", "_solved.json")
    with open(output_file, 'w') as f:
        json.dump(result, f, indent=2)
    
    print(f"\nSaved to: {output_file}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python solution.py <input_json>")
        sys.exit(1)
    solve_and_output(sys.argv[1])